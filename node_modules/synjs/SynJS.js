"use strict";

/**
 * SynJS
 * @module SynJS
 * @author Alexei Maximov amaksr
 * @licence AGPLv3
 * @version 0.1
 */
(function(exports){
    if(!exports.console)
        exports.console = {error: function () {}, log: function () {}};
	var Syn = function() {
		this.localVars = {};
	};
    Syn.states = Syn.states || {};
    Syn.stateSeq = 0;
    Syn.prototype.parse = function(str) {
        var idx = ss(str,0);
        if(!startingWith(str,idx,'function'))
            throw "expected 'function'";

        idx = ss(str,idx+8);
        if(str.charAt(idx) != "(") {
            this.functionName = parseVarname(str,idx);
            idx +=this.functionName.length;
            idx = ss(str,idx);
        }
        if(str.charAt(idx) != "(" )
            throw "expected '\"'";
        idx++;
        idx = ss(str,idx);
        var pname;
        this.params = [];
        while(pname = parseVarname(str,idx) ) {
            this.localVars[pname] = 1;
            this.params.push(pname);
            idx += pname.length;
            idx = ss(str,idx);
            if(str.charAt(idx) == ',') {
                idx++;
                idx = ss(str,idx);
                continue;
            }
            if(str.charAt(idx) == ')') {
                idx++;
                idx = ss(str,idx);
                break;
            }
            throw "unexpected token " + str.charAt(idx);
        }
        this.operatorBlock = new StmtBlock(this);
        idx = this.operatorBlock.parse(str,idx);
        idx++;
        return idx;
    };

    Syn.prototype.execute = function (state) {
        this.operatorBlock.execute(state);
        Syn.tick(state);
    };

    /**
     *
     * @param {State} state
     */
    Syn.tick = function (state) {
        while(state.stack.length > 0) {
            var stackEl = state.stack[state.stack.length - 1];
            var cont = stackEl.program.executeStep.call(stackEl.program,state,stackEl);
            if(!cont) {
                return;
            }
        }
        var cb = state.finCb;
        if(cb) {
            state.finCb = null;
            cb.call(state.userThisCtx,state.retVal);
            delete Syn.states[state.id];
        }
    };

    Syn.exists = function(state) {
        return !!Syn.states[state.id];
    };

    Syn.isRunning = function(state) {
        return this.exists(state) && !!state.finCb;
    };

    /**
     * waits until condition is true
     * @param maxWaitTime wait time
     */
    Syn.wait = function(maxWaitTime) {
        console.error("SynJS.wait is not intended to be called directly");
    };
    /**
     *
     * @param labelExpr wait time
     */
    Syn.wait = function(labelExpr) {
        console.error("SynJS.goto is not intended to be called directly");
    };

    /**
     * continues execution
     * @param {State} state
     */
    Syn.resume = function(state) {
        setTimeout(function () {
            Syn.tick(state);
        },0);
    };

    Syn.prototype.lVars = function (str) {
        var idx = 0;
        var varNames = {};
        var ap = false;
        while( idx < str.length ) {
            idx = ss(str,idx);
            var char = str.substr(idx,1);
            if(char=='"' || char=="'") {
                idx++;
                // loop to the end of string
                for( ;idx<str.length; idx++) {
                    var c = str.substr(idx,1);
                    if(c=="\\") idx++;
                    else if (c == char)
                        break;
                }
                ap = false;
                idx++;
            }
            else if (isVarnameBegin(char)) {
                {
                    var vn = parseVarname(str,idx);
                    varNames[vn] = 1;
                    idx += vn.length;
                    if(!ap && this.localVars.hasOwnProperty(vn)){
                        var newVarName = "_synjsContext.localVars."+vn;
                        str = str.substr(0,idx - vn.length) + newVarName + str.substr(idx);
                        idx += newVarName.length - vn.length;
                    }
                }
                // loop to the end of varname
                ap = false;
            }
            else if (char == '.') {
                ap = true;
                idx++;
            }
            else if (isDigit(char)) {
                // loop to the end of number
                for( ;idx<str.length; idx++) {
                    var c = str.substr(idx,1);
                    if(!isDigit(c) && c != '.')
                        break;
                }
                ap = false;
                idx++;
            }
            else {
                ap = false;
                idx++;
            }
            idx = ss(str,idx);
        }
        return str;
    };

    var State = function(id, synjsBin, userThisCtx, finCb, params) {
        this.id = id;
        this.synjsBin = synjsBin;
        this.userThisCtx = userThisCtx;
        this.finCb = finCb;
        this.params = params;
        this.stack = [];
        this.localVars = {};
        this.retVal = null;

        for(var i=0; i<params.length; i++)
            this.localVars[this.synjsBin.params[i]] = params[i];

    };



    var StmtIf = function(root) {
		this.root = root;
        this.source = null;
		this.opCondSource = null;
		this.func1 = function () { throw('stub is not redefined'); }; // stub
		this.opBodyTrueBin = null;
		this.opBodyFalseBin = null;
	};
	StmtIf.prototype.parse = function (str,idx) {
	    var start = idx;
		idx = ss(str,idx+2);
		if(str.substr(idx,1) !=  '(')
			throw "expected  '('";
		idx = ss(str,idx+1);

		var opCondStart = idx;
		idx = Syn.findEndOfStatement(str,idx,')');
		this.opCondSource = this.root.lVars(str.substr(opCondStart,idx-opCondStart));
		eval("this.func1 = function(_synjsContext) { return "+this.opCondSource+"}");

		idx = ss(str,idx+1);

        this.opBodyTrueBin = stmtDetect(this.root,str,idx,true);
        this.opBodyTrueBin = stmtDetect(this.root,str,idx,true);
        if(this.opBodyTrueBin.labelSkip) idx = this.opBodyTrueBin.labelSkip;
		idx = this.opBodyTrueBin.parse(str,idx);

        idx = skipOptSemicolon(str,idx);

		// optional else
		if(startingWith(str,idx,'else')) {
			idx = ss(str,idx+4);
            this.opBodyFalseBin = stmtDetect(this.root, str,idx,true);
            if(this.opBodyFalseBin.labelSkip) idx = this.opBodyFalseBin.labelSkip;
            idx = this.opBodyFalseBin.parse(str,idx);
		}
        this.source = str.substr(start,idx-start);
        idx = skipOptSemicolon(str,idx);
        return idx;
	};
    /**
     *
     * @param {State} state
     */
	StmtIf.prototype.execute = function(state) {
        var cond = this.func1.call(state.userThisCtx,state);
        var stmt = cond?this.opBodyTrueBin:this.opBodyFalseBin;
        if(stmt) stmt.execute(state);
    };

    var StmtDoWhile = function(root) {
        this.root = root;
        this.breakable = true;
        this.source = null;
    };
    StmtDoWhile.prototype.parse = function (str,idx) {
        var start = idx;
        idx = ss(str,idx+2);
        this.opBodyBin = stmtDetect(this.root,str,idx,true);
        if(this.opBodyBin.labelSkip) idx = this.opBodyBin.labelSkip;
        idx = this.opBodyBin.parse(str,idx);

        idx = ss(str,idx);
        idx = skipOptSemicolon(str,idx);
        if(!startingWith(str,idx,'while'))
            throw "Expected 'while'";

        idx = ss(str,idx+5);

        if(str.substr(idx,1) !=  '(')
            throw "expected  '('";

        idx = ss(str,idx+1);

        var op1Start = idx;
        idx = Syn.findEndOfStatement(str,idx,')');
        this.op1Source = this.root.lVars(str.substr(op1Start,idx-op1Start));
        eval("this.func1 = function(_synjsContext) { return " + this.op1Source + "}");

        idx = ss(str,idx+1);

        this.source = str.substr(start,idx-start);
        idx = skipOptSemicolon(str,idx);
        return idx;
    };
    /**
     *
     * @param {State} state
     */
    StmtDoWhile.prototype.execute = function(state) {
        var o = {
            nxt: StmtDoWhile.prototype.executeStepBody,
            program: this
        };
        state.stack.push(o);
    };
    /**
     *
     * @param {State} state
     * @param stackEl
     * @returns {*}
     */
    StmtDoWhile.prototype.executeStep = function(state, stackEl) {
        var nxt = stackEl.nxt;
        return nxt(state,stackEl);
    };
    StmtDoWhile.prototype.executeStepBody = function(state,stackEl) {
        stackEl.nxt = StmtDoWhile.prototype.executeStepCond;
        if(state.finCb) {
            var stmt = stackEl.program.opBodyBin;
            stmt.execute(state);
        }
        return true;
    };
    StmtDoWhile.prototype.executeStepCond = function(state,stackEl) {
        stackEl.nxt = StmtDoWhile.prototype.executeStepBody;
        if(!state.finCb || !stackEl.program.func1.call(state.userThisCtx,state))
            state.stack.pop();
        return true;
    };

    var StmtWhile = function(root) {
        this.root = root;
        this.breakable = true;
        this.source = null;
    };
    StmtWhile.prototype.parse = function (str,idx) {
        var start = idx;
        idx = ss(str,idx+5);
        if(str.substr(idx,1) !=  '(')
            throw "expected  '('";
        idx = ss(str,idx+1);

        var op1Start = idx;
        idx = Syn.findEndOfStatement(str,idx,')');
        this.op1Source = this.root.lVars(str.substr(op1Start,idx-op1Start));
        eval("this.func1 = function(_synjsContext) { return " + this.op1Source + "}");

        idx = ss(str,idx+1);

        this.opBodyBin = stmtDetect(this.root,str,idx,true);
        if(this.opBodyBin.labelSkip) idx = this.opBodyBin.labelSkip;
        idx = this.opBodyBin.parse(str,idx);

        this.source = str.substr(start,idx-start);
        idx = skipOptSemicolon(str,idx);
        return idx;
    };
    /**
     *
     * @param {State} state
     */
    StmtWhile.prototype.execute = function(state) {
        var o = {
            program: this
        };
        state.stack.push(o);
    };
    /**
     *
     * @param {State} state
     * @param stackEl
     * @returns {boolean}
     */
    StmtWhile.prototype.executeStep = function(state,stackEl) {
        if(state.finCb && stackEl.program.func1.call(state.userThisCtx,state) ) {
            var stmt = stackEl.program.opBodyBin;
            stmt.execute(state);
        }
        else
            state.stack.pop();
        return true;
    };

    var StmtForIn = function(root) {
        this.root = root;
        this.breakable = true;
        this.source = null;
        this.label = null;
        this.varStmtSource = null;
        this.varStmtBin = null;
        this.varName = null;
        this.onExprSource = null;
    };
    StmtForIn.prototype.parse = function (str,idx) {
        var start = idx;
        idx = ss(str,idx+3);
        if(str.substr(idx,1) !=  '(')
            throw "expected  '('";
        idx = ss(str,idx+1);
        var vs1=idx;
        if(startingWith(str,idx,'var')) {
            idx = ss(str,idx+3);
            var vn = parseVarname(str,idx);
            this.varStmtSource = this.root.lVars( str.substr(vs1, vn.length+idx-vs1) );
            this.varStmtBin = new StmtVar(this.root);
            this.varStmtBin.parse(this.varStmtSource,0);
            this.varName = vn;
            idx = ss(str,idx+vn.length);
        }
        else {
            this.varName = parseVarname(str,idx);
            idx = ss(str, idx+this.varName.length);
        }
        if(startingWith(str,idx,'in'))
            this.type = 'in';
        else if(startingWith(str,idx,'of'))
            throw "for ... of ... cycle is not supported";
        else
            throw "Expected 'in'";
        idx = ss(str,idx+2);
        vs1=idx;
        idx = Syn.findEndOfStatement(str,idx,')');
        this.onExprSource = this.root.lVars(str.substr(vs1,idx-vs1));
        eval("this.onExprFunc = function(_synjsContext) { return " + this.onExprSource + "}");
        eval("this.assignFunc = function(_synjsContext,_synjsV) { return " + this.root.lVars(this.varName) + " = _synjsV }");
        idx = ss(str,idx+1);
        this.opBodyBin = stmtDetect(this.root,str,idx,true);
        if(this.opBodyBin.labelSkip) idx = this.opBodyBin.labelSkip;
        idx = this.opBodyBin.parse(str,idx);

        this.source = str.substr(start,idx-start);
        idx = skipOptSemicolon(str,idx);
        return idx;
    };

    StmtForIn.prototype.execute = function(state) {
        var a = [];
        for(var k in this.onExprFunc.call(state.userThisCtx,state))
            a.push(k);
        var o = {
            program: this,
            onExprValues: a,
            pc: 0
        };
        state.stack.push(o);
    };

    StmtForIn.prototype.executeStep = function(state,stackEl) {
        if(state.finCb && stackEl.pc < stackEl.onExprValues.length) {
            this.assignFunc(state,stackEl.onExprValues[stackEl.pc]);
            stackEl.pc++;
            var stmt = stackEl.program.opBodyBin;
            stmt.execute(state);
        }
        else
            state.stack.pop();
        return true;
    };

    var StmtFor = function(root) {
		this.root = root;
		this.breakable = true;
        this.source = null;
        this.label = null;
	};
	StmtFor.prototype.parse = function (str,idx) {
        var start = idx;
		idx = ss(str,idx+3);
		if(str.substr(idx,1) !=  '(')
			throw "expected  '('";
		idx = ss(str,idx+1);

		var op1Start = idx;
		idx = Syn.findEndOfStatement(str,idx,';');
		var op1End = idx;
        this.op1Source = str.substr(op1Start,op1End-op1Start);
		if(startingWith(this.op1Source,0,'var'))
            this.op1Bin = new StmtVar(this.root);
		else
            this.op1Bin = new StmtSingle(this.root);
		this.op1Bin.parse(this.op1Source,0);

		idx = ss(str,idx+1);

		var op2Start = idx;
		idx = Syn.findEndOfStatement(str,idx,';');
		var op2End = idx;
		this.op2Source = this.root.lVars(str.substr(op2Start,op2End-op2Start));
		eval("this.func2 = function(_synjsContext) { return " + this.op2Source + "}");

		idx = ss(str,idx+1);

		var op3Start = idx;
		idx = Syn.findEndOfStatement(str,idx,')');
		var op3End = idx;
		this.op3Source = this.root.lVars(str.substr(op3Start,op3End-op3Start));
		eval("this.func3 = function(_synjsContext) {"+this.op3Source+"}");

		idx = ss(str,idx+1);

        this.opBodyBin = stmtDetect(this.root,str,idx,true);
        if(this.opBodyBin.labelSkip) idx = this.opBodyBin.labelSkip;
        idx = this.opBodyBin.parse(str,idx);

        this.source = str.substr(start,idx-start);
        idx = skipOptSemicolon(str,idx);
        return idx;
	};
    /**
     *
     * @param {State} state
     */
	StmtFor.prototype.execute = function(state) {
		var o = {
            nxt: StmtFor.prototype.executeStepBody,
            program: this
		};
        state.stack.push(o);
		this.op1Bin.execute(state);
    };
    /**
     *
     * @param {State} state
     * @param stackEl
     * @returns {*}
     */
    StmtFor.prototype.executeStep = function(state,stackEl) {
        var nxt = stackEl.nxt;
        return nxt(state,stackEl);
    };
	StmtFor.prototype.executeStepBody = function(state,stackEl) {
        stackEl.nxt = StmtFor.prototype.executeStepInc;
        if(state.finCb && stackEl.program.func2.call(state.userThisCtx,state)) {
            var stmt = stackEl.program.opBodyBin;
            stmt.execute(state);
        }
        else
            state.stack.pop();
        return true;
    };
    StmtFor.prototype.executeStepInc = function(state,stackEl) {
        stackEl.nxt = StmtFor.prototype.executeStepBody;
        if(state.finCb)
            stackEl.program.func3.call(state.userThisCtx,state);
        return true;
    };

	function stmtDetect(root, str, idx, checkLabel) {
        var stmt;
        var label;
        var labelSkip;
        idx = ss(str, idx);
        if(checkLabel) {
            var lbl = parseVarname(str,idx);
            if( lbl.length > 0 ) {
                var j = ss(str,idx + lbl.length);
                if(str.substr(j,1) == ':') {
                    label = lbl;
                    idx = ss(str,j+1);
                    labelSkip = idx;
                }
            }
        }
        if(str.substr(idx,1) ==  '{')
            stmt = new StmtBlock(root);
        else if(startingWith(str,idx,'var'))
            stmt = new StmtVar(root);
        else if(startingWith(str,idx,'if'))
            stmt = new StmtIf(root);
        else if(startingWith(str,idx,'for')) {
            var i = ss(str,idx+3);
            i = ss(str,i+1);
            if(startingWith(str,i,'var')) i=ss(str,i+3);
            var v = parseVarname(str,i);
            i=ss(str,i+v.length);
            if(startingWith(str,i,'in') || startingWith(str,i,'of'))
                stmt = new StmtForIn(root);
            else
                stmt = new StmtFor(root);
        }
        else if(startingWith(str,idx,'switch'))
            stmt = new StmtSwitch(root);
        else if(startingWith(str,idx,'while'))
            stmt = new StmtWhile(root);
        else if(startingWith(str,idx,'do'))
            stmt = new StmtDoWhile(root);
        else if(startingWith(str,idx,'break'))
            stmt = new StmtBreak(root);
        else if(startingWith(str,idx,'tick'))
            stmt = new StmtContinue(root);
        else if(startingWith(str,idx,'return'))
            stmt = new StmtReturn(root);
        else if(startingWith(str,idx,'SynJS.wait'))
            stmt = new StmtWait(root);
        else if(startingWith(str,idx,'SynJS.goto'))
            stmt = new StmtGoto(root);
        else if(startingWith(str,idx,'let'))
            throw "Not implemented: 'let'";
        else if(startingWith(str,idx,'const'))
            throw "Not implemented: 'const'";
        else if(startingWith(str,idx,'try'))
            throw "Not implemented: 'try'";
        else
            stmt = new StmtSingle(root);
        stmt.label = label;
        stmt.labelSkip = labelSkip;
        return stmt;

    }

    var StmtSwitch = function(root){
        this.root = root;
        this.source = null;
        this.stmtBlock = new StmtBlock(root);
        this.cases = [];
        this.breakable = true;
        this.label = null;
        this.defIndex = null;
    };
    StmtSwitch.prototype.parse = function(str,idx) {
        var start = idx;
        idx = ss(str, idx+6);
        if(str.substr(idx,1) !=  '(')
            throw "expected  '('";
        idx = ss(str,idx+1);

        var op1Start = idx;
        idx = Syn.findEndOfStatement(str,idx,')');
        this.op1Source = this.root.lVars(str.substr(op1Start,idx-op1Start));
        eval("this.func1 = function(_synjsContext) { return " + this.op1Source + "}");

        idx = ss(str,idx+1);

        if(str.substr(idx,1) !=  '{')
            throw "expected  '{'";

        idx = ss(str,idx+1);

        while(str.substr(idx,1) != '}' && idx < str.length) {
            idx = ss(str, idx);

            if(startingWith(str,idx,'case')) {
                idx = ss(str, idx+4);
                var st = idx;
                idx = Syn.findEndOfStatement(str,idx,':');
                if(str.substr(idx,1)!=':')
                    throw "expected  ':'";

                var co={};
                co.exprSource = this.root.lVars(str.substr(st,idx-st));
                eval("co.exprFunc = function(_synjsContext) { return " + co.exprSource + "}");
                co.index = this.stmtBlock.ops.length;
                this.cases.push(co);
                idx = ss(str, idx+1);
                continue;
            }

            if(startingWith(str,idx,'default')) {
                idx = ss(str, idx+7);
                if(str.substr(idx,1)!=':')
                    throw "expected  ':'";
                this.defIndex = this.stmtBlock.ops.length;
                idx = ss(str, idx+1);
                continue;
            }

            var stmt = stmtDetect(this.root, str, idx, true);
            if(stmt.labelSkip) idx = stmt.labelSkip;
            idx = stmt.parse(str,idx);
            this.stmtBlock.ops.push(stmt);
            idx = ss(str, idx);
        }
        if(idx >= str.length)
            throw "unexpected end of statement";
        idx++;
        this.source = str.substr(start,idx-start);
        return idx;
    };

    /**
     *
     * @param {State} state
     */
    StmtSwitch.prototype.execute = function(state) {
        var val = this.func1.call(state.userThisCtx,state);
        var pc = this.defIndex;
        for(var i=0; i<this.cases.length; i++) {
            var caseVal = this.cases[i].exprFunc.call(state.userThisCtx,state);
            if(val == caseVal) {
                pc = this.cases[i].index;
                break;
            }
        }
        state.stack.push({
            pc: 0,
            program: this
        });
        state.stack.push({
            pc: pc,
            program: this.stmtBlock
        });
    };
    StmtSwitch.prototype.executeStep = function (state,stackEl) {
        state.stack.pop();
        return true;
    };


    var StmtBlock = function(root){
        this.root = root;
        this.source = null;
        this.ops = [];
        this.labels = {};
    };
	StmtBlock.prototype.parse = function(str,idx) {
        var start = idx;
        idx = ss(str, idx+1);
		while(str.substr(idx,1) != '}' && idx < str.length) {
			idx = ss(str, idx);
            var stmt = stmtDetect(this.root, str, idx, true);
            if(stmt.labelSkip) idx = stmt.labelSkip;
            idx = stmt.parse(str,idx);
            if(stmt.label)
                this.labels[stmt.label] = this.ops.length;
            this.ops.push(stmt);
			idx = ss(str, idx);
		};
        if(idx >= str.length)
            throw "unexpected end of statement";
        idx++;
        this.source = str.substr(start,idx-start);
		return idx;
	};
    /**
     *
     * @param {State} state
     */
	StmtBlock.prototype.execute = function (state) {
		var o = {
			pc: 0,
            program: this
		};
		state.stack.push(o);
    };
    /**
     *
     * @param {State} state
     * @param stackEl
     * @returns {boolean}
     */
	StmtBlock.prototype.executeStep = function (state,stackEl) {
        if(stackEl.pc >= stackEl.program.ops.length) {
            state.stack.pop();
            return true;
        }
        var stmt = stackEl.program.ops[stackEl.pc];
        stackEl.pc++;
        stmt.execute(state);

		return true;
	};


	var StmtVar = function(root){
		this.root = root;
		this.noCallback = true;
        this.source = null;
	};
	StmtVar.prototype.parse = function(str,idx) {
        var start = idx;
		idx = ss(str,idx);
		var opStart = idx;
		idx = Syn.findEndOfStatement(str,idx,';');
		this.opSource = str.substr(opStart,idx-opStart);
		this.assignSteps = [];
		this.extractVarNames();
        idx++;
        this.source = str.substr(start,idx-start);
        return idx;
	};
	StmtVar.prototype.extractVarNames = function() {
		var st = ss(this.opSource, "var".length);
		var str = this.opSource.substr(st);
		var idx = 0;
		while(idx < str.length) {
			idx = ss(str,idx);
			var opStart = idx;
			idx = Syn.findEndOfStatement(str,idx,',');
			var el = str.substr(opStart,idx-opStart);
			var varName = parseVarname(el,0);
			if(!varName)
				throw "variable name expected";
			var valueExpr;
			var eq = el.indexOf('=');
			if(eq >= 0) {
				valueExpr = el.substr(eq + 1);
				valueExpr = this.root.lVars(valueExpr);
				eval("this.assignSteps.push(function(_synjsContext) {\n" +
					"	_synjsContext.localVars."+varName+"="+valueExpr+";\n" +
					"})\n");
			}
			this.root.localVars[varName] = valueExpr;
			idx++;
		}
	};
    /**
     *
     * @param {State} state
     */
	StmtVar.prototype.execute = function(state) {
        for(var i=0; i<this.assignSteps.length; i++)
			this.assignSteps[i].call(state.userThisCtx,state);
	};



	var StmtSingle = function(root){
		this.root = root;
		this.noCallback = true;
        this.source = null;
	};
	StmtSingle.prototype.parse = function(str,idx) {
        var start = idx;
		idx = ss(str,idx);
		var opStart = idx;
		idx = Syn.findEndOfStatement(str,idx,';');
		this.opSource = this.root.lVars(str.substr(opStart,idx-opStart));
		eval("this.body = function(_synjsContext) {\n" +
			"	"+this.opSource+";\n" +
			"}\n");
        this.source = str.substr(start,idx-start);
        idx = skipOptSemicolon(str,idx);
        return idx;
	};
    /**
     *
     * @param {State} state
     */
	StmtSingle.prototype.execute = function(state) {
		this.body.call(state.userThisCtx,state);
	};

    var StmtGoto = function(root){
        this.root = root;
        this.source = "";
        this.label = "";
    };
    StmtGoto.prototype.parse = function(str,idx) {
        var start = idx;
        idx = ss(str,idx+"SynJS.goto".length);
        if(str.substr(idx,1) != "(")
            throw "expected (";
        idx = ss(str,idx+1);
        var opStart = idx;
        idx=Syn.findEndOfStatement(str,idx,')');
        this.op1Source = this.root.lVars(str.substr(opStart,idx-opStart));
        eval("this.func1 = function(_synjsContext) { return " + this.op1Source + " }");
        if(str.substr(idx,1)!=')')
            throw "expected )";
        idx++;
        this.source = str.substr(start,idx-start);
        idx = skipOptSemicolon(str,idx);
        return idx;
    };
    /**
     *
     * @param {State} state
     */
    StmtGoto.prototype.execute = function(state) {
        var lblTo = this.func1.call(state.userThisCtx,state);
        while(state.stack.length > 0) {
            var e = state.stack[state.stack.length-1];
            if(e.program.labels && e.program.labels[lblTo] >= 0){
                e.pc = e.program.labels[lblTo];
                return;
            }
            else
                state.stack.pop();
        }
        throw "cannot find label '"+lblTo+"'";
    };


    var StmtBreak = function(root){
		this.root = root;
        this.source = "";
        this.label = "";
	};
	StmtBreak.prototype.parse = function(str,idx) {
        var start = idx;
        idx = ss(str,idx+5);
        var lbl = parseVarname(str,idx);
        if( lbl.length ) {
            this.label = lbl;
            idx = ss(str,idx+lbl.length);
        }
        this.source = str.substr(start,idx-start);
        idx = skipOptSemicolon(str,idx);
        return idx;
	};

    /**
     *
     * @param {State} state
     */
	StmtBreak.prototype.execute = function(state) {
		while(state.stack.length > 0) {
		    var e = state.stack.pop();
            if(!this.label && e.program.breakable || this.label && e.program.label == this.label)
                    return;
		}
    	throw "Illegal break";
	};

    var StmtContinue = function(root){
        this.root = root;
        this.source = "";
        this.label = "";
    };
    StmtContinue.prototype.parse = function(str,idx) {
        var start = idx;
        idx = ss(str,idx+8);
        var lbl = parseVarname(str,idx);
        if( lbl.length ) {
            this.label = lbl;
            idx = ss(str,idx+lbl.length);
        }
        this.source = str.substr(start,idx-start);
        idx = skipOptSemicolon(str,idx);
        return idx;
    };
    /**
     *
     * @param {State} state
     */
    StmtContinue.prototype.execute = function(state) {
        for(var i = state.stack.length - 1; i >=0; i--) {
            var e = state.stack[i];
            if(e.program.breakable && (!this.label || this.label && this.label == e.program.label) )
                return;
            state.stack.pop();
        }
        throw "Illegal tick";
    };

    var StmtReturn = function(root){
        this.root = root;
        this.source = null;
    };
    StmtReturn.prototype.parse  = function (str,idx) {
        var start = idx;
        idx = ss(str,idx + 'return'.length);
        var opStart = idx;
        idx = Syn.findEndOfStatement(str,idx,';');
        this.opSource = this.root.lVars(str.substr(opStart,idx-opStart));
        eval("this.func1 = function(_synjsContext) {" +
            "   return " + this.opSource + " " +
            "}");
        this.source = str.substr(start,idx-start);
        idx = skipOptSemicolon(str,idx);
        return idx;
    };
    /**
     *
     * @param {State} state
     */
    StmtReturn.prototype.execute = function (state) {
        state.retVal = this.func1.call(state.userThisCtx,state);
        state.stack = [];
    };


    var StmtWait = function(root){
		this.root = root;
        this.source = null;
        this.op1Source = null;
        this.func1 = function () {return true};
	};
	StmtWait.prototype.parse = function (str,idx) {
        var start = idx;
		idx = ss(str,idx + 'SynJS.wait'.length);
        if(str.substr(idx,1)!='(')
            throw "expected (";
        idx = ss(str,idx + 1);
		var opStart = idx;
		idx = Syn.findEndOfStatement(str,idx,')');
		this.op1Source = this.root.lVars(str.substr(opStart,idx-opStart));
		eval("this.func1 = function(_synjsContext) { return " + this.op1Source + " }");
        if(str.substr(idx,1)!=')')
            throw "expected )";
        idx++;
        this.source = str.substr(start,idx-start);
        idx = skipOptSemicolon(str,idx);
        return idx;
	};
    /**
     *
     * @param {State} state
     */
	StmtWait.prototype.execute = function (state) {
        state.stack.push({
            program:    this,
            arg: this.func1.call(state.userThisCtx,state)
        });
	};
    /**
     *
     * @param {State} state
     * @param stackEl
     * @returns {boolean}
     */
	StmtWait.prototype.executeStep = function (state,stackEl) {
        if(typeof stackEl.arg == 'number' && stackEl.timeoutId ||
            typeof stackEl.arg != 'number' && this.func1.call(state.userThisCtx,state) ||
            typeof stackEl.arg == 'undefined' && stackEl.running
        ) {
            state.stack.pop();
            return true;
        }
	    if(typeof stackEl.arg == 'number') {
            stackEl.timeoutId = setTimeout(function () {
                Syn.tick(state);
            },stackEl.arg);
        }
        stackEl.running = true;
        return false;
	};


	Syn.findEndOfStatement = function (str, idx, closingChar) {
		var stack=[];
		var quote;
		for(; idx < str.length; idx++) {
			var c = str.substr(idx,1);
			if(!quote) {
			    if(c == '/') {
			        if(str.substr(idx,2) == '//' || str.substr(idx,2) == '/*') {
                        idx = skipComment(str,idx);
                        idx--;
                        continue;
                    }
                }
				if(stack.length == 0 && c == closingChar) {
					return idx;
				}
				if(c == '(' || c == '{' || c == '[')
					stack.push(c);
				else if(c == ')' || c == '}' || c == ']') {
				    if(stack.length == 0)
				        return idx;
					var pc = stack.pop();
					if(pc != '[' && c == ']')
						throw "Unexpected: ]";
					if(pc != '(' && c == ')')
						throw "Unexpected: )";
					if(pc != '{' && c == '}')
						throw "Unexpected: }";
				}
				else if(c == "'" || c == '"')
					quote = c;
			}
			else {
				if( quote == '\\')
					idx++;
				else if(quote == c)
					quote = null;
			}
		}
		if(stack.length>0)	throw "Unexpected eof in statement, no closing brackets for "+JSON.stringify(stack);
		if(quote)	throw "Unexpected eof in statement, no closing quote "+quote;
		return idx;
    };

    function skipComment(str, idx) {
        if(str.substr(idx,2) == '//') {
            idx = skipSLComment(str,idx);
        }
        else if(str.substr(idx,2) == '/*'){
            idx = skipMLComment(str,idx);
        }
        return idx;
	};

	function skipMLComment(str, idx) {
		for(idx+=2; idx < str.length; idx++)
			if(str.substr(idx,2) == "*/")
				return idx+2;
	};

	function skipSLComment(str, idx) {
		for(idx+=2; idx < str.length; idx++)
			if(str.substr(idx,1) == "\n")
				return idx+1;
		return idx;
	};

	Syn._isSpace = function(s) {
		return(s==" " || s=="\t"  || s=="\n"  || s=="\r" || s=="â†µ");
	};

	function ss(str,idx) {
		var s;
		while(s = str.substr(idx,1)) {
		    if(s == '/') {
		        if(str.substr(idx,2) == '//' || str.substr(idx,2) == '/*') {
		            idx = skipComment(str,idx);
                }
                else
                    idx++;
                continue;
            }
			if(!Syn._isSpace(s))
				break;
			idx++;
		}
		return idx;
	}

	function isLetter(chr) {
		return "a" <= chr && chr <= "z" ||
			"A" <= chr && chr <= "Z";
	}

	function isDigit(chr) {
		return "0" <= chr && chr <= "9";
	}

	function isVarnameBegin(chr) {
		return isLetter(chr) || chr == "$" || chr == "_"
	}

	function isVarnameCont(chr) {
		return isLetter(chr) || isDigit(chr) || chr == "$" || chr == "_"
	}

    /**
     * Synchronous run
     * @param {Function} functionPtr
     * @param userThisCtx
     * @param {Function} callback
     */
    var run = function(functionPtr, userThisCtx, /*param1, param2, etc*/ callback) {
        var params = Array.prototype.slice.call(arguments);
        var functionPtr = params.shift();
        if(typeof functionPtr != 'function')
            throw "function pointer expected";
        var userThisCtx = params.shift() || {};
        var callback = params.pop() || function () {};
        if(!functionPtr._synjsBin) {
            functionPtr._synjsBin = new Syn();
            functionPtr._synjsBin.parse(functionPtr.toString());
        }
        var state = new State(Syn.stateSeq, functionPtr._synjsBin, userThisCtx, callback, params);
        Syn.states[Syn.stateSeq] = state;
        Syn.stateSeq++;
        functionPtr._synjsBin.execute(state);
        return state;
    };

	function parseVarname(str,idx) {
		idx = ss(str,idx);
		var res="";
		for(var i=idx; i<str.length; i++) {
			var chr = str.charAt(i);
			if(i==idx && isVarnameBegin(chr) || i>idx && isVarnameCont(chr))
				res+=chr;
			else
				break;
		}
		return res;
	}

	function startingWith(str,idx,word) {
		return str.substr(idx,word.length) == word && !isVarnameCont(str.substr(idx+word.length,1));
	}

	function skipOptSemicolon(str, idx) {
        idx = ss(str,idx);
        if(str.substr(idx,1) == ';') idx++;
        idx = ss(str,idx);
        return idx;
    };

    exports.run = run;
    exports.wait = Syn.wait;
    exports.goto = Syn.goto;
    exports.resume = Syn.resume;
    exports.states = Syn.states;
    exports.isRunning = Syn.isRunning;
    exports.exists = Syn.exists;
})(typeof exports === 'undefined'? this['SynJS']={} : exports);
